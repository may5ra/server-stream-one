import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

interface Stream {
  name: string;
  input_url: string;
  input_type: string;
}

function generateProxyConfig(streams: Stream[], serverIp: string, httpPort: string): string {
  const port = httpPort || '8080';
  const ip = serverIp || 'localhost';

  const generateProxyLocations = () => {
    if (streams.length === 0) {
      return `    # Nema eksternih streamova u bazi`;
    }

    return streams.map(stream => {
      const streamName = stream.name.toLowerCase().replace(/[^a-z0-9]/g, '_');
      const inputUrl = stream.input_url.trim();
      
      let baseUrl = inputUrl;
      if (inputUrl.endsWith('.m3u8') || inputUrl.endsWith('.ts')) {
        baseUrl = inputUrl.substring(0, inputUrl.lastIndexOf('/'));
      }
      if (baseUrl.endsWith('/')) {
        baseUrl = baseUrl.slice(0, -1);
      }

      return `    # Stream: ${stream.name}
    location /proxy/${streamName}/ {
        proxy_pass ${baseUrl}/;
        proxy_http_version 1.1;
        proxy_set_header Host $proxy_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_buffering off;
        proxy_cache off;
        
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods 'GET, OPTIONS';
    }`;
    }).join('\n\n');
  };

  return `# Stream Proxy Config - Generated by StreamPanel
server {
    listen ${port};
    server_name ${ip};

    add_header Access-Control-Allow-Origin * always;
    add_header Access-Control-Allow-Methods 'GET, OPTIONS' always;

    if ($request_method = 'OPTIONS') {
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods 'GET, OPTIONS';
        add_header Content-Length 0;
        return 204;
    }

${generateProxyLocations()}

    location /proxy/health {
        access_log off;
        return 200 'OK';
        add_header Content-Type text/plain;
    }
}`;
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    const { serverIp, httpPort, action } = await req.json()
    
    // Get agent settings from secrets
    const agentHost = Deno.env.get('SSH_HOST') || serverIp
    const agentPort = Deno.env.get('AGENT_PORT') || '9876'
    const agentSecret = Deno.env.get('AGENT_SECRET')

    if (!agentSecret) {
      console.error('AGENT_SECRET not configured')
      return new Response(
        JSON.stringify({ 
          error: 'Agent secret not configured',
          instructions: 'Add AGENT_SECRET in Secrets settings'
        }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    const agentUrl = `http://${agentHost}:${agentPort}`
    console.log(`Connecting to agent at: ${agentUrl}`)

    // If just testing connection
    if (action === 'health') {
      try {
        const healthCheck = await fetch(agentUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${agentSecret}`
          },
          body: JSON.stringify({ action: 'health' })
        })
        const healthData = await healthCheck.json()
        return new Response(
          JSON.stringify({ success: true, agent: healthData }),
          { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        )
      } catch (err) {
        return new Response(
          JSON.stringify({ 
            success: false, 
            error: 'Cannot connect to agent',
            details: err instanceof Error ? err.message : 'Unknown error'
          }),
          { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        )
      }
    }

    // Fetch streams from database
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    const supabase = createClient(supabaseUrl, supabaseKey)

    const { data: streams, error: dbError } = await supabase
      .from('streams')
      .select('name, input_url, input_type')
      .order('name', { ascending: true })

    if (dbError) {
      console.error('Database error:', dbError)
      return new Response(
        JSON.stringify({ error: 'Failed to fetch streams' }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Filter external streams
    const externalStreams = (streams || []).filter((s: Stream) => 
      s.input_type === 'hls' || 
      s.input_type === 'http' || 
      s.input_url?.startsWith('http')
    )

    console.log(`Found ${externalStreams.length} external streams`)

    // Generate config
    const config = generateProxyConfig(externalStreams, serverIp || agentHost, httpPort)
    
    // Send to agent
    console.log('Sending config to agent...')
    const agentResponse = await fetch(agentUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${agentSecret}`
      },
      body: JSON.stringify({
        action: 'write-config',
        config: config
      })
    })

    const agentResult = await agentResponse.json()
    console.log('Agent response:', agentResult)

    if (!agentResponse.ok) {
      return new Response(
        JSON.stringify({ 
          success: false, 
          error: agentResult.error || 'Agent error',
          details: agentResult
        }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Generate stream mappings
    const streamMappings = externalStreams.map((s: Stream) => {
      const streamName = s.name.toLowerCase().replace(/[^a-z0-9]/g, '_')
      return {
        name: s.name,
        proxyUrl: `http://${serverIp || agentHost}:${httpPort}/proxy/${streamName}/index.m3u8`,
        originalUrl: s.input_url
      }
    })

    return new Response(
      JSON.stringify({ 
        success: true,
        message: `Config deployed! ${externalStreams.length} streams configured.`,
        agentResult: agentResult,
        streamMappings: streamMappings
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    console.error('Deploy error:', errorMessage)
    return new Response(
      JSON.stringify({ error: errorMessage }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }
})
