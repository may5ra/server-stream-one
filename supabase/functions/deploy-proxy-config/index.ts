import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

interface Stream {
  name: string;
  input_url: string;
  input_type: string;
}

function generateProxyConfig(streams: Stream[], serverIp: string, httpPort: string): string {
  const port = httpPort || '8080';
  const ip = serverIp || 'localhost';

  const generateProxyLocations = () => {
    if (streams.length === 0) {
      return `    # Nema eksternih streamova u bazi`;
    }

    return streams.map(stream => {
      const streamName = stream.name.toLowerCase().replace(/[^a-z0-9]/g, '_');
      const inputUrl = stream.input_url.trim();
      
      let baseUrl = inputUrl;
      if (inputUrl.endsWith('.m3u8') || inputUrl.endsWith('.ts')) {
        baseUrl = inputUrl.substring(0, inputUrl.lastIndexOf('/'));
      }
      if (baseUrl.endsWith('/')) {
        baseUrl = baseUrl.slice(0, -1);
      }

      return `    # Stream: ${stream.name}
    location /proxy/${streamName}/ {
        proxy_pass ${baseUrl}/;
        proxy_http_version 1.1;
        proxy_set_header Host $proxy_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_buffering off;
        proxy_cache off;
        
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods 'GET, OPTIONS';
    }`;
    }).join('\n\n');
  };

  return `# Stream Proxy Config - Generated by StreamPanel
server {
    listen ${port};
    server_name ${ip};

    add_header Access-Control-Allow-Origin * always;
    add_header Access-Control-Allow-Methods 'GET, OPTIONS' always;

    if ($request_method = 'OPTIONS') {
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods 'GET, OPTIONS';
        add_header Content-Length 0;
        return 204;
    }

${generateProxyLocations()}

    location /proxy/health {
        access_log off;
        return 200 'OK';
        add_header Content-Type text/plain;
    }
}`;
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    const { serverIp, httpPort } = await req.json()
    
    console.log(`Deploying proxy config to server: ${serverIp}:${httpPort}`)

    // Get SSH credentials
    const sshHost = Deno.env.get('SSH_HOST')
    const sshUsername = Deno.env.get('SSH_USERNAME')
    const sshPassword = Deno.env.get('SSH_PASSWORD')

    if (!sshHost || !sshUsername || !sshPassword) {
      console.error('SSH credentials not configured')
      return new Response(
        JSON.stringify({ error: 'SSH credentials not configured. Configure them in Settings.' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Fetch streams from database
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    const supabase = createClient(supabaseUrl, supabaseKey)

    const { data: streams, error: dbError } = await supabase
      .from('streams')
      .select('name, input_url, input_type')
      .order('name', { ascending: true })

    if (dbError) {
      console.error('Database error:', dbError)
      return new Response(
        JSON.stringify({ error: 'Failed to fetch streams from database' }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Filter external streams
    const externalStreams = (streams || []).filter((s: Stream) => 
      s.input_type === 'hls' || 
      s.input_type === 'http' || 
      s.input_url?.startsWith('http')
    )

    console.log(`Found ${externalStreams.length} external streams`)

    // Generate the config
    const config = generateProxyConfig(externalStreams, serverIp || sshHost, httpPort)
    
    // Escape the config for shell command
    const escapedConfig = config.replace(/'/g, "'\\''")
    
    // Commands to deploy the config
    const commands = [
      `echo '${escapedConfig}' | sudo tee /etc/nginx/sites-available/stream-proxy > /dev/null`,
      `sudo ln -sf /etc/nginx/sites-available/stream-proxy /etc/nginx/sites-enabled/stream-proxy`,
      `sudo nginx -t`,
      `sudo systemctl reload nginx`
    ]

    console.log('Deploying config via SSH...')
    
    // For now, return the config and commands since Deno Deploy doesn't support SSH directly
    // In production, you'd use a service that can execute SSH commands
    
    const streamMappings = externalStreams.map((s: Stream) => {
      const streamName = s.name.toLowerCase().replace(/[^a-z0-9]/g, '_')
      return {
        name: s.name,
        proxyUrl: `http://${serverIp || sshHost}:${httpPort}/proxy/${streamName}/index.m3u8`,
        originalUrl: s.input_url
      }
    })

    return new Response(
      JSON.stringify({ 
        success: true,
        message: `Config generated for ${externalStreams.length} streams`,
        config: config,
        commands: commands,
        streamMappings: streamMappings,
        instructions: [
          'SSH to your server and run these commands:',
          ...commands
        ]
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    console.error('Deploy error:', errorMessage)
    return new Response(
      JSON.stringify({ error: errorMessage }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }
})
