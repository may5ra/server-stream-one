import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface Stream {
  id: string;
  name: string;
  input_url: string;
  input_type: string;
  proxy_mode: string;
}

interface LoadBalancer {
  id: string;
  name: string;
  ip_address: string;
  port: number;
  nginx_port: number;
  ssh_username: string;
  ssh_password: string;
}

// Generate Nginx configuration - simple reverse proxy to main server (like XUI)
// LB just forwards all requests to main, main handles auth and routing
function generateNginxConfig(streams: Stream[], lbPort: number, mainServerUrl: string): string {
  // Stream list for debug
  const streamList = streams.map((s) => {
    const normalized = s.name.toLowerCase().replace(/[^a-z0-9]/g, "");
    return `"${normalized}"`;
  }).join(",");

  return `# Auto-generated by StreamPanel Load Balancer
# Generated: ${new Date().toISOString()}
# Streams: ${streams.length}
# Mode: Simple Reverse Proxy to Main Server (like XUI)
# Main Server: ${mainServerUrl}

server {
    listen ${lbPort};
    server_name _;
    
    resolver 8.8.8.8 8.8.4.4 valid=300s;
    resolver_timeout 5s;

    # Increase header limits to avoid 400 Request Header Or Cookie Too Large
    large_client_header_buffers 8 32k;
    client_header_buffer_size 32k;

    # Health check
    location /health {
        default_type text/plain;
        return 200 'OK';
    }

    # Stream status
    location /status {
        default_type application/json;
        return 200 '{"streams": ${streams.length}, "generated": "${new Date().toISOString()}", "main_server": "${mainServerUrl}", "names": [${streamList}] }';
    }

    # Forward ALL requests to main server - main handles auth, routing, everything
    location / {
        proxy_pass ${mainServerUrl};
        proxy_http_version 1.1;
        
        # IMPORTANT: Pass the upstream Host, not LB host - prevents redirect loops
        proxy_set_header Host ${new URL(mainServerUrl).host};
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-From-LB "1";

        # Strip cookies before forwarding to main server to avoid huge Cookie headers
        proxy_set_header Cookie "";
        
        # Disable redirect rewriting - let main server URLs pass through as-is
        proxy_redirect off;
        
        # Streaming optimizations
        proxy_buffering off;
        proxy_cache off;
        proxy_request_buffering off;
        chunked_transfer_encoding on;
        
        # Timeouts for long streams
        proxy_connect_timeout 10s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
        
        # Buffer settings
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;
        
        # CORS
        add_header Access-Control-Allow-Origin * always;
        add_header Access-Control-Allow-Methods 'GET, OPTIONS' always;
        add_header Access-Control-Expose-Headers 'Content-Length,Content-Range' always;
    }
}`;
}


// Helper to escape regex special characters
function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { action, loadBalancerId } = await req.json();
    
    console.log(`LB Deploy action: ${action}, LB ID: ${loadBalancerId}`);

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Get load balancer details
    const { data: lb, error: lbError } = await supabase
      .from('load_balancers')
      .select('*')
      .eq('id', loadBalancerId)
      .single();

    if (lbError || !lb) {
      console.error('Load balancer not found:', lbError);
      return new Response(
        JSON.stringify({ error: 'Load balancer not found' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (!lb.ssh_username || !lb.ssh_password) {
      console.error('SSH credentials not configured for LB');
      return new Response(
        JSON.stringify({ error: 'SSH credentials not configured for this Load Balancer' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Get streams assigned to this load balancer
    const { data: streams, error: streamsError } = await supabase
      .from('streams')
      .select('id, name, input_url, input_type, proxy_mode')
      .eq('load_balancer_id', loadBalancerId);

    if (streamsError) {
      console.error('Error fetching streams:', streamsError);
      return new Response(
        JSON.stringify({ error: 'Failed to fetch streams' }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Get main server URL from settings - first try main_server_url, then build from server_domain + http_port
    const { data: mainServerSetting } = await supabase
      .from('panel_settings')
      .select('value')
      .eq('key', 'main_server_url')
      .single();
    
    let mainServerUrl = mainServerSetting?.value;
    
    // If main_server_url not set, build from server_domain and http_port
    if (!mainServerUrl) {
      const { data: domainSetting } = await supabase
        .from('panel_settings')
        .select('value')
        .eq('key', 'server_domain')
        .single();
      
      const { data: portSetting } = await supabase
        .from('panel_settings')
        .select('value')
        .eq('key', 'http_port')
        .single();
      
      const domain = domainSetting?.value || 'localhost';
      const port = portSetting?.value || '80';
      mainServerUrl = `http://${domain}:${port}`;
    }
    console.log(`Main server URL: ${mainServerUrl}`);

    // Generate simple reverse proxy config pointing to main server
    const nginxConfig = generateNginxConfig(streams || [], lb.nginx_port || 80, mainServerUrl);
    console.log(`Generated config for ${streams?.length || 0} streams`);

    // Agent always runs on port 3002
    const AGENT_PORT = '3002';
    const AGENT_SECRET = 'superbase123';

    if (action === 'test') {
      // Test agent connection
      const agentUrl = `http://${lb.ip_address}:${AGENT_PORT}/health`;
      console.log(`Testing agent at ${agentUrl}`);
      try {
        const testResponse = await fetch(agentUrl, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
          signal: AbortSignal.timeout(5000),
        });
        
        if (testResponse.ok) {
          return new Response(
            JSON.stringify({ 
              success: true, 
              message: 'Agent connection successful',
              streams: streams?.length || 0
            }),
            { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
          );
        }
      } catch (e) {
        console.log('Agent not available, will try direct SSH');
      }

      return new Response(
        JSON.stringify({ 
          success: true, 
          message: 'Ready for deployment',
          config: nginxConfig,
          streams: streams?.length || 0
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (action === 'deploy') {
      // Try to deploy via agent - agent runs on port 3002
      const agentUrl = `http://${lb.ip_address}:${AGENT_PORT}`;
      
      let deploySuccess = false;
      let deployMessage = '';

      console.log(`Attempting deploy to agent at ${agentUrl}`);

      try {
        // Step 1: Write config file
        const writeResponse = await fetch(agentUrl, {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'X-Agent-Secret': AGENT_SECRET
          },
          body: JSON.stringify({
            action: 'execute',
            command: `cat > /etc/nginx/sites-available/streampanel-lb.conf << 'NGINXEOF'
${nginxConfig}
NGINXEOF`
          }),
          signal: AbortSignal.timeout(30000),
        });

        console.log(`Write config response: ${writeResponse.status}`);
        const writeResult = await writeResponse.json();
        console.log('Write result:', JSON.stringify(writeResult));

        if (writeResponse.ok && writeResult.success) {
          // Step 2: Enable site and reload nginx
          const reloadResponse = await fetch(agentUrl, {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'X-Agent-Secret': AGENT_SECRET
            },
            body: JSON.stringify({
              action: 'execute',
              command: 'ln -sf /etc/nginx/sites-available/streampanel-lb.conf /etc/nginx/sites-enabled/ && nginx -t && systemctl reload nginx'
            }),
            signal: AbortSignal.timeout(30000),
          });

          console.log(`Reload nginx response: ${reloadResponse.status}`);
          const reloadResult = await reloadResponse.json();
          console.log('Reload result:', JSON.stringify(reloadResult));

          if (reloadResponse.ok && reloadResult.success) {
            deploySuccess = true;
            deployMessage = 'Configuration deployed and nginx reloaded successfully';
          } else {
            deployMessage = `Nginx reload failed: ${reloadResult.output || 'Unknown error'}`;
          }
        } else {
          deployMessage = `Config write failed: ${writeResult.output || 'Unknown error'}`;
        }
      } catch (e) {
        const errorMsg = e instanceof Error ? e.message : 'Unknown error';
        console.log('Agent deployment failed:', errorMsg);
        deployMessage = `Agent error: ${errorMsg}`;
      }

      // Update last_deploy timestamp
      await supabase
        .from('load_balancers')
        .update({ last_deploy: new Date().toISOString() })
        .eq('id', loadBalancerId);

      // Generate stream URLs for this LB - use normalized stream name (lowercase, alphanumeric)
      const streamMappings = (streams || []).map(stream => {
        const normalizedName = stream.name.toLowerCase().replace(/[^a-z0-9]/g, "");
        return {
          name: stream.name,
          normalizedName: normalizedName,
          originalUrl: stream.input_url,
          proxyUrl: `http://${lb.ip_address}:${lb.nginx_port || 80}/live/${normalizedName}.ts?username=USER&password=PASS`
        };
      });

      return new Response(
        JSON.stringify({ 
          success: deploySuccess,
          message: deployMessage,
          config: nginxConfig,
          streams: streamMappings,
          loadBalancer: {
            name: lb.name,
            ip: lb.ip_address,
            port: lb.nginx_port || 80
          }
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (action === 'get-config') {
      return new Response(
        JSON.stringify({ 
          success: true,
          config: nginxConfig,
          streams: streams?.length || 0
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    return new Response(
      JSON.stringify({ error: 'Invalid action' }),
      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('LB Deploy error:', errorMessage);
    return new Response(
      JSON.stringify({ error: errorMessage }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
