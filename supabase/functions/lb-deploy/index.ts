import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface Stream {
  id: string;
  name: string;
  input_url: string;
  input_type: string;
  proxy_mode: string;
}

interface LoadBalancer {
  id: string;
  name: string;
  ip_address: string;
  port: number;
  nginx_port: number;
  ssh_username: string;
  ssh_password: string;
}

// Generate Nginx proxy configuration for streams with authentication
function generateNginxConfig(streams: Stream[], lbPort: number, supabaseUrl: string, supabaseKey: string): string {
  // Build stream map for location matching
  const streamLocations = streams.map((stream) => {
    // Use exact stream name for matching (case insensitive)
    const streamName = stream.name;
    const inputUrl = stream.input_url;
    
    return `
    # Stream: ${streamName}
    location ~* "^/live/${escapeRegex(streamName)}\\.ts$" {
        # Auth is handled by auth_request
        
        proxy_pass ${inputUrl};
        proxy_http_version 1.1;
        proxy_set_header Host $proxy_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header User-Agent "VLC/3.0.20 LibVLC/3.0.20";
        proxy_buffering off;
        proxy_cache off;
        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;
        
        # CORS headers
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, OPTIONS' always;
    }`;
  }).join('\n');

  return `# Auto-generated by StreamPanel Load Balancer
# Generated: ${new Date().toISOString()}
# Streams: ${streams.length}

# Supabase config for auth
map $arg_username $auth_username {
    default $arg_username;
}
map $arg_password $auth_password {
    default $arg_password;
}

server {
    listen ${lbPort};
    server_name _;
    
    resolver 8.8.8.8 8.8.4.4 valid=300s;
    resolver_timeout 5s;

    # Health check
    location /health {
        return 200 'OK';
        add_header Content-Type text/plain;
    }

    # Stream status
    location /status {
        return 200 '{"streams": ${streams.length}, "generated": "${new Date().toISOString()}"}';
        add_header Content-Type application/json;
    }

    # Auth subrequest endpoint
    location = /_auth {
        internal;
        proxy_pass ${supabaseUrl}/rest/v1/streaming_users?select=id,expiry_date&username=eq.$arg_username&password=eq.$arg_password;
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
        proxy_set_header apikey "${supabaseKey}";
        proxy_set_header Authorization "Bearer ${supabaseKey}";
        proxy_set_header Content-Type "application/json";
        proxy_set_header Prefer "return=representation";
    }

    # Live streams - format: /live/STREAMNAME.ts?username=X&password=Y
    location ~ ^/live/(.+)\\.ts$ {
        set $stream_name $1;
        
        # Check for credentials
        if ($arg_username = "") {
            return 401 "Missing username";
        }
        if ($arg_password = "") {
            return 401 "Missing password";
        }
        
        # Auth request to Supabase
        auth_request /_auth;
        auth_request_set $auth_status $upstream_status;
        
        # CORS for OPTIONS
        if ($request_method = 'OPTIONS') {
            add_header 'Access-Control-Allow-Origin' '*';
            add_header 'Access-Control-Allow-Methods' 'GET, OPTIONS';
            add_header 'Access-Control-Allow-Headers' 'Range';
            add_header 'Access-Control-Max-Age' 1728000;
            return 204;
        }

        # Try to match specific streams defined below
        # This location acts as a wrapper, actual proxying happens in named locations
        try_files /nonexistent @stream_router;
    }

    # Stream router - matches stream name to input URL
    location @stream_router {
        # This is handled by the specific stream locations above
        # If no match, return 404
        return 404 "Stream not found";
    }

${streamLocations}

    # Fallback
    location / {
        return 404 'Not found';
        add_header Content-Type text/plain;
    }
}`;
}

// Escape special regex characters for Nginx location matching
function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\\\$&');
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { action, loadBalancerId } = await req.json();
    
    console.log(`LB Deploy action: ${action}, LB ID: ${loadBalancerId}`);

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Get load balancer details
    const { data: lb, error: lbError } = await supabase
      .from('load_balancers')
      .select('*')
      .eq('id', loadBalancerId)
      .single();

    if (lbError || !lb) {
      console.error('Load balancer not found:', lbError);
      return new Response(
        JSON.stringify({ error: 'Load balancer not found' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (!lb.ssh_username || !lb.ssh_password) {
      console.error('SSH credentials not configured for LB');
      return new Response(
        JSON.stringify({ error: 'SSH credentials not configured for this Load Balancer' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Get streams assigned to this load balancer
    const { data: streams, error: streamsError } = await supabase
      .from('streams')
      .select('id, name, input_url, input_type, proxy_mode')
      .eq('load_balancer_id', loadBalancerId);

    if (streamsError) {
      console.error('Error fetching streams:', streamsError);
      return new Response(
        JSON.stringify({ error: 'Failed to fetch streams' }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Get anon key for auth requests
    const anonKey = Deno.env.get('SUPABASE_ANON_KEY') || supabaseKey;
    const nginxConfig = generateNginxConfig(streams || [], lb.nginx_port || 80, supabaseUrl, anonKey);
    console.log(`Generated config for ${streams?.length || 0} streams`);

    // Agent always runs on port 3002
    const AGENT_PORT = '3002';
    const AGENT_SECRET = 'superbase123';

    if (action === 'test') {
      // Test agent connection
      const agentUrl = `http://${lb.ip_address}:${AGENT_PORT}/health`;
      console.log(`Testing agent at ${agentUrl}`);
      try {
        const testResponse = await fetch(agentUrl, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
          signal: AbortSignal.timeout(5000),
        });
        
        if (testResponse.ok) {
          return new Response(
            JSON.stringify({ 
              success: true, 
              message: 'Agent connection successful',
              streams: streams?.length || 0
            }),
            { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
          );
        }
      } catch (e) {
        console.log('Agent not available, will try direct SSH');
      }

      return new Response(
        JSON.stringify({ 
          success: true, 
          message: 'Ready for deployment',
          config: nginxConfig,
          streams: streams?.length || 0
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (action === 'deploy') {
      // Try to deploy via agent - agent runs on port 3002
      const agentUrl = `http://${lb.ip_address}:${AGENT_PORT}`;
      
      let deploySuccess = false;
      let deployMessage = '';

      console.log(`Attempting deploy to agent at ${agentUrl}`);

      try {
        // Step 1: Write config file
        const writeResponse = await fetch(agentUrl, {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'X-Agent-Secret': AGENT_SECRET
          },
          body: JSON.stringify({
            action: 'execute',
            command: `cat > /etc/nginx/sites-available/streampanel-lb.conf << 'NGINXEOF'
${nginxConfig}
NGINXEOF`
          }),
          signal: AbortSignal.timeout(30000),
        });

        console.log(`Write config response: ${writeResponse.status}`);
        const writeResult = await writeResponse.json();
        console.log('Write result:', JSON.stringify(writeResult));

        if (writeResponse.ok && writeResult.success) {
          // Step 2: Enable site and reload nginx
          const reloadResponse = await fetch(agentUrl, {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'X-Agent-Secret': AGENT_SECRET
            },
            body: JSON.stringify({
              action: 'execute',
              command: 'ln -sf /etc/nginx/sites-available/streampanel-lb.conf /etc/nginx/sites-enabled/ && nginx -t && systemctl reload nginx'
            }),
            signal: AbortSignal.timeout(30000),
          });

          console.log(`Reload nginx response: ${reloadResponse.status}`);
          const reloadResult = await reloadResponse.json();
          console.log('Reload result:', JSON.stringify(reloadResult));

          if (reloadResponse.ok && reloadResult.success) {
            deploySuccess = true;
            deployMessage = 'Configuration deployed and nginx reloaded successfully';
          } else {
            deployMessage = `Nginx reload failed: ${reloadResult.output || 'Unknown error'}`;
          }
        } else {
          deployMessage = `Config write failed: ${writeResult.output || 'Unknown error'}`;
        }
      } catch (e) {
        const errorMsg = e instanceof Error ? e.message : 'Unknown error';
        console.log('Agent deployment failed:', errorMsg);
        deployMessage = `Agent error: ${errorMsg}`;
      }

      // Update last_deploy timestamp
      await supabase
        .from('load_balancers')
        .update({ last_deploy: new Date().toISOString() })
        .eq('id', loadBalancerId);

      // Generate stream URLs for this LB - use exact stream name format
      const streamMappings = (streams || []).map(stream => ({
        name: stream.name,
        originalUrl: stream.input_url,
        proxyUrl: `http://${lb.ip_address}:${lb.nginx_port || 80}/live/${encodeURIComponent(stream.name)}.ts?username=USER&password=PASS`
      }));

      return new Response(
        JSON.stringify({ 
          success: deploySuccess,
          message: deployMessage,
          config: nginxConfig,
          streams: streamMappings,
          loadBalancer: {
            name: lb.name,
            ip: lb.ip_address,
            port: lb.nginx_port || 80
          }
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (action === 'get-config') {
      return new Response(
        JSON.stringify({ 
          success: true,
          config: nginxConfig,
          streams: streams?.length || 0
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    return new Response(
      JSON.stringify({ error: 'Invalid action' }),
      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('LB Deploy error:', errorMessage);
    return new Response(
      JSON.stringify({ error: errorMessage }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
