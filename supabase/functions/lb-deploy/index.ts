import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface Stream {
  id: string;
  name: string;
  input_url: string;
  input_type: string;
  proxy_mode: string;
}

interface LoadBalancer {
  id: string;
  name: string;
  ip_address: string;
  port: number;
  nginx_port: number;
  ssh_username: string;
  ssh_password: string;
}

// Generate Nginx proxy configuration for streams
function generateNginxConfig(streams: Stream[], lbPort: number): string {
  const locations = streams.map((stream, index) => {
    const streamPath = stream.name.toLowerCase().replace(/[^a-z0-9]/g, '_');
    return `
    # Stream: ${stream.name}
    location /live/${streamPath}/ {
        proxy_pass ${stream.input_url};
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_buffering off;
        proxy_cache off;
        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;
        
        # CORS headers
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Range,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type' always;
        
        # Handle OPTIONS
        if ($request_method = 'OPTIONS') {
            add_header 'Access-Control-Allow-Origin' '*';
            add_header 'Access-Control-Max-Age' 1728000;
            add_header 'Content-Type' 'text/plain charset=UTF-8';
            add_header 'Content-Length' 0;
            return 204;
        }
    }`;
  }).join('\n');

  return `# Auto-generated by StreamPanel Load Balancer
# Generated: ${new Date().toISOString()}

server {
    listen ${lbPort};
    server_name _;

    # Health check
    location /health {
        return 200 'OK';
        add_header Content-Type text/plain;
    }

    # Stream status
    location /status {
        return 200 '{"streams": ${streams.length}, "generated": "${new Date().toISOString()}"}';
        add_header Content-Type application/json;
    }

${locations}

    # Fallback
    location / {
        return 404 'Stream not found';
        add_header Content-Type text/plain;
    }
}`;
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { action, loadBalancerId } = await req.json();
    
    console.log(`LB Deploy action: ${action}, LB ID: ${loadBalancerId}`);

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Get load balancer details
    const { data: lb, error: lbError } = await supabase
      .from('load_balancers')
      .select('*')
      .eq('id', loadBalancerId)
      .single();

    if (lbError || !lb) {
      console.error('Load balancer not found:', lbError);
      return new Response(
        JSON.stringify({ error: 'Load balancer not found' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (!lb.ssh_username || !lb.ssh_password) {
      console.error('SSH credentials not configured for LB');
      return new Response(
        JSON.stringify({ error: 'SSH credentials not configured for this Load Balancer' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Get streams assigned to this load balancer
    const { data: streams, error: streamsError } = await supabase
      .from('streams')
      .select('id, name, input_url, input_type, proxy_mode')
      .eq('load_balancer_id', loadBalancerId);

    if (streamsError) {
      console.error('Error fetching streams:', streamsError);
      return new Response(
        JSON.stringify({ error: 'Failed to fetch streams' }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const nginxConfig = generateNginxConfig(streams || [], lb.nginx_port || 8080);
    console.log(`Generated config for ${streams?.length || 0} streams`);

    if (action === 'test') {
      // Test SSH connection
      const agentUrl = `http://${lb.ip_address}:${Deno.env.get('AGENT_PORT') || '3002'}/health`;
      
      try {
        const testResponse = await fetch(agentUrl, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
          signal: AbortSignal.timeout(5000),
        });
        
        if (testResponse.ok) {
          return new Response(
            JSON.stringify({ 
              success: true, 
              message: 'Agent connection successful',
              streams: streams?.length || 0
            }),
            { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
          );
        }
      } catch (e) {
        console.log('Agent not available, will try direct SSH');
      }

      return new Response(
        JSON.stringify({ 
          success: true, 
          message: 'Ready for deployment',
          config: nginxConfig,
          streams: streams?.length || 0
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (action === 'deploy') {
      // Try to deploy via agent first - agent uses root path with action in body
      const agentPort = Deno.env.get('AGENT_PORT') || '3002';
      const agentUrl = `http://${lb.ip_address}:${agentPort}`;
      const agentSecret = Deno.env.get('AGENT_SECRET') || 'superbase123';
      
      let deploySuccess = false;
      let deployMessage = '';

      console.log(`Attempting deploy to agent at ${agentUrl} with secret`);

      try {
        // Step 1: Write config file
        const writeResponse = await fetch(agentUrl, {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'X-Agent-Secret': agentSecret
          },
          body: JSON.stringify({
            action: 'execute',
            command: `cat > /etc/nginx/sites-available/streampanel-lb.conf << 'NGINXEOF'
${nginxConfig}
NGINXEOF`
          }),
          signal: AbortSignal.timeout(30000),
        });

        console.log(`Write config response: ${writeResponse.status}`);
        const writeResult = await writeResponse.json();
        console.log('Write result:', JSON.stringify(writeResult));

        if (writeResponse.ok && writeResult.success) {
          // Step 2: Enable site and reload nginx
          const reloadResponse = await fetch(agentUrl, {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'X-Agent-Secret': agentSecret
            },
            body: JSON.stringify({
              action: 'execute',
              command: 'ln -sf /etc/nginx/sites-available/streampanel-lb.conf /etc/nginx/sites-enabled/ && nginx -t && systemctl reload nginx'
            }),
            signal: AbortSignal.timeout(30000),
          });

          console.log(`Reload nginx response: ${reloadResponse.status}`);
          const reloadResult = await reloadResponse.json();
          console.log('Reload result:', JSON.stringify(reloadResult));

          if (reloadResponse.ok && reloadResult.success) {
            deploySuccess = true;
            deployMessage = 'Configuration deployed and nginx reloaded successfully';
          } else {
            deployMessage = `Nginx reload failed: ${reloadResult.output || 'Unknown error'}`;
          }
        } else {
          deployMessage = `Config write failed: ${writeResult.output || 'Unknown error'}`;
        }
      } catch (e) {
        const errorMsg = e instanceof Error ? e.message : 'Unknown error';
        console.log('Agent deployment failed:', errorMsg);
        deployMessage = `Agent error: ${errorMsg}`;
      }

      // Update last_deploy timestamp
      await supabase
        .from('load_balancers')
        .update({ last_deploy: new Date().toISOString() })
        .eq('id', loadBalancerId);

      // Generate stream URLs for this LB
      const streamMappings = (streams || []).map(stream => ({
        name: stream.name,
        originalUrl: stream.input_url,
        proxyUrl: `http://${lb.ip_address}:${lb.nginx_port || 8080}/live/${stream.name.toLowerCase().replace(/[^a-z0-9]/g, '_')}/`
      }));

      return new Response(
        JSON.stringify({ 
          success: deploySuccess,
          message: deployMessage,
          config: nginxConfig,
          streams: streamMappings,
          loadBalancer: {
            name: lb.name,
            ip: lb.ip_address,
            port: lb.nginx_port || 8080
          }
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (action === 'get-config') {
      return new Response(
        JSON.stringify({ 
          success: true,
          config: nginxConfig,
          streams: streams?.length || 0
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    return new Response(
      JSON.stringify({ error: 'Invalid action' }),
      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('LB Deploy error:', errorMessage);
    return new Response(
      JSON.stringify({ error: errorMessage }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
