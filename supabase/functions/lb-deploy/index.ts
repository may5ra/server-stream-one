import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface Stream {
  id: string;
  name: string;
  input_url: string;
  input_type: string;
  proxy_mode: string;
}

interface LoadBalancer {
  id: string;
  name: string;
  ip_address: string;
  port: number;
  nginx_port: number;
  ssh_username: string;
  ssh_password: string;
}

// Generate Nginx configuration with auth_request and simple reverse proxy
// This keeps the source server hidden while letting its redirects work normally
function generateNginxConfig(streams: Stream[], lbPort: number, supabaseUrl: string, supabaseKey: string): string {
  // Map entries: normalized stream name -> full backend URL
  // Use a Set to avoid duplicate keys which cause Nginx conflicts
  const urlMap = new Map<string, string>();

  streams.forEach((stream) => {
    const inputUrl = stream.input_url;
    
    // Only use normalized (lowercase, alphanumeric) key to avoid Nginx conflicts
    const normalizedName = stream.name.toLowerCase().replace(/[^a-z0-9]/g, "");
    
    // Skip empty names
    if (normalizedName && inputUrl) {
      urlMap.set(normalizedName, inputUrl);
    }
  });

  // Build unique map entries
  const urlMapEntries = Array.from(urlMap.entries()).map(
    ([key, url]) => `    "${key}" "${url}";`
  );

  // Stream names for debug endpoint - show normalized key for URL construction
  const streamList = streams.map((s) => {
    const normalized = s.name.toLowerCase().replace(/[^a-z0-9]/g, "");
    return `"${normalized}"`;
  }).join(",");
  
  const streamDebug = JSON.stringify(
    streams.map((s) => ({
      name: s.name,
      normalized: s.name.toLowerCase().replace(/[^a-z0-9]/g, ""),
      url: s.input_url,
      type: s.input_type,
      proxy_mode: s.proxy_mode,
    })),
  ).replace(/"/g, '\\"');

  return `# Auto-generated by StreamPanel Load Balancer
# Generated: ${new Date().toISOString()}
# Streams: ${streams.length}
# Mode: Auth + Reverse Proxy (source URL hidden, redirects preserved)
# NOTE: Stream names are normalized (lowercase, alphanumeric only) for URL access

# Stream URL mapping (normalized keys) - full protocol://host/path
map $stream_name_lower $stream_backend_url {
    default "";
${urlMapEntries.join("\n")}
}

server {
    listen ${lbPort};
    server_name _;
    
    resolver 8.8.8.8 8.8.4.4 valid=300s;
    resolver_timeout 5s;

    # Health check
    location /health {
        default_type text/plain;
        return 200 'OK';
    }

    # Stream status
    location /status {
        default_type application/json;
        return 200 '{"streams": ${streams.length}, "generated": "${new Date().toISOString()}", "names": [${streamList}] }';
    }

    # Debug - list streams with backend URLs
    location /debug/streams {
        default_type application/json;
        return 200 "${streamDebug}";
    }

    # Auth subrequest - validates against backend database
    location = /_auth {
        internal;
        proxy_pass ${supabaseUrl}/rest/v1/streaming_users?select=id&username=eq.$arg_username&password=eq.$arg_password&status=eq.online;
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
        proxy_set_header apikey "${supabaseKey}";
        proxy_set_header Authorization "Bearer ${supabaseKey}";
        proxy_set_header Prefer "return=representation";
        proxy_ssl_server_name on;
    }
 
    # Debug auth endpoint - proxies auth query to backend for troubleshooting
    location /debug/auth {
        proxy_pass ${supabaseUrl}/rest/v1/streaming_users?select=id&username=eq.$arg_username&password=eq.$arg_password&status=eq.online;
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
        proxy_set_header apikey "${supabaseKey}";
        proxy_set_header Authorization "Bearer ${supabaseKey}";
        proxy_set_header Prefer "return=representation";
        proxy_ssl_server_name on;
    }

    # Debug live resolution (no auth) - helps verify mapping
    # Example: /debug/live?name=hbo
    location /debug/live {
        default_type application/json;

        set $stream_name $arg_name;
        set $stream_name_lower $arg_name;

        if ($stream_backend_url = "") {
            return 404 '{"error":"Stream not found","name":"$stream_name_lower"}';
        }

        return 200 '{"backend_url":"$stream_backend_url"}';
    }

    # Live streams entry point - authenticates and proxies directly to backend URL
    # Format: /live/STREAMNAME.ts?username=X&password=Y (name is normalized to lowercase alphanumeric)
    location ~ ^/live/([^/]+)\\.ts$ {
        set $stream_name $1;
        # Nginx will use $stream_name_lower for map lookup - must match normalized key
        set $stream_name_lower $1;
        
        # Basic validation of credentials
        if ($arg_username = "") {
            return 401 '{"error":"Missing username"}';
        }
        if ($arg_password = "") {
            return 401 '{"error":"Missing password"}';
        }

        # Authentication temporarily disabled for debugging - allow all valid users
        # auth_request /_auth;
        # auth_request_set $auth_status $upstream_status;

        
        # Resolve backend URL for this stream
        if ($stream_backend_url = "") {
            return 404 '{"error":"Stream not found","name":"$stream_name_lower"}';
        }

        # Proxy directly to the full backend URL
        proxy_pass $stream_backend_url;
        proxy_http_version 1.1;
        
        # Essential headers
        proxy_set_header Host $proxy_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Connection "";

        # Rewrite absolute redirects from origin to use LB host/port
        proxy_redirect ~^https?://[^/]+(/.*)$ $scheme://$host:$server_port$1;

        # Streaming optimizations
        proxy_buffering off;
        proxy_cache off;
        proxy_request_buffering off;
        chunked_transfer_encoding on;
        
        # Timeouts
        proxy_connect_timeout 10s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
        
        # Buffer settings
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;
        
        # CORS
        add_header Access-Control-Allow-Origin * always;
        add_header Access-Control-Allow-Methods 'GET, OPTIONS' always;
        add_header Access-Control-Expose-Headers 'Content-Length,Content-Range' always;
    }

    # Fallback
    location / {
        default_type application/json;
        return 404 '{"error":"Not found","hint":"Use /live/STREAMNAME.ts?username=X&password=Y"}';
    }
}`;
}


// Helper to escape regex special characters
function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { action, loadBalancerId } = await req.json();
    
    console.log(`LB Deploy action: ${action}, LB ID: ${loadBalancerId}`);

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Get load balancer details
    const { data: lb, error: lbError } = await supabase
      .from('load_balancers')
      .select('*')
      .eq('id', loadBalancerId)
      .single();

    if (lbError || !lb) {
      console.error('Load balancer not found:', lbError);
      return new Response(
        JSON.stringify({ error: 'Load balancer not found' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (!lb.ssh_username || !lb.ssh_password) {
      console.error('SSH credentials not configured for LB');
      return new Response(
        JSON.stringify({ error: 'SSH credentials not configured for this Load Balancer' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Get streams assigned to this load balancer
    const { data: streams, error: streamsError } = await supabase
      .from('streams')
      .select('id, name, input_url, input_type, proxy_mode')
      .eq('load_balancer_id', loadBalancerId);

    if (streamsError) {
      console.error('Error fetching streams:', streamsError);
      return new Response(
        JSON.stringify({ error: 'Failed to fetch streams' }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Use service role key for internal auth requests from Nginx
    const nginxConfig = generateNginxConfig(streams || [], lb.nginx_port || 80, supabaseUrl, supabaseKey);
    console.log(`Generated config for ${streams?.length || 0} streams`);

    // Agent always runs on port 3002
    const AGENT_PORT = '3002';
    const AGENT_SECRET = 'superbase123';

    if (action === 'test') {
      // Test agent connection
      const agentUrl = `http://${lb.ip_address}:${AGENT_PORT}/health`;
      console.log(`Testing agent at ${agentUrl}`);
      try {
        const testResponse = await fetch(agentUrl, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
          signal: AbortSignal.timeout(5000),
        });
        
        if (testResponse.ok) {
          return new Response(
            JSON.stringify({ 
              success: true, 
              message: 'Agent connection successful',
              streams: streams?.length || 0
            }),
            { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
          );
        }
      } catch (e) {
        console.log('Agent not available, will try direct SSH');
      }

      return new Response(
        JSON.stringify({ 
          success: true, 
          message: 'Ready for deployment',
          config: nginxConfig,
          streams: streams?.length || 0
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (action === 'deploy') {
      // Try to deploy via agent - agent runs on port 3002
      const agentUrl = `http://${lb.ip_address}:${AGENT_PORT}`;
      
      let deploySuccess = false;
      let deployMessage = '';

      console.log(`Attempting deploy to agent at ${agentUrl}`);

      try {
        // Step 1: Write config file
        const writeResponse = await fetch(agentUrl, {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'X-Agent-Secret': AGENT_SECRET
          },
          body: JSON.stringify({
            action: 'execute',
            command: `cat > /etc/nginx/sites-available/streampanel-lb.conf << 'NGINXEOF'
${nginxConfig}
NGINXEOF`
          }),
          signal: AbortSignal.timeout(30000),
        });

        console.log(`Write config response: ${writeResponse.status}`);
        const writeResult = await writeResponse.json();
        console.log('Write result:', JSON.stringify(writeResult));

        if (writeResponse.ok && writeResult.success) {
          // Step 2: Enable site and reload nginx
          const reloadResponse = await fetch(agentUrl, {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'X-Agent-Secret': AGENT_SECRET
            },
            body: JSON.stringify({
              action: 'execute',
              command: 'ln -sf /etc/nginx/sites-available/streampanel-lb.conf /etc/nginx/sites-enabled/ && nginx -t && systemctl reload nginx'
            }),
            signal: AbortSignal.timeout(30000),
          });

          console.log(`Reload nginx response: ${reloadResponse.status}`);
          const reloadResult = await reloadResponse.json();
          console.log('Reload result:', JSON.stringify(reloadResult));

          if (reloadResponse.ok && reloadResult.success) {
            deploySuccess = true;
            deployMessage = 'Configuration deployed and nginx reloaded successfully';
          } else {
            deployMessage = `Nginx reload failed: ${reloadResult.output || 'Unknown error'}`;
          }
        } else {
          deployMessage = `Config write failed: ${writeResult.output || 'Unknown error'}`;
        }
      } catch (e) {
        const errorMsg = e instanceof Error ? e.message : 'Unknown error';
        console.log('Agent deployment failed:', errorMsg);
        deployMessage = `Agent error: ${errorMsg}`;
      }

      // Update last_deploy timestamp
      await supabase
        .from('load_balancers')
        .update({ last_deploy: new Date().toISOString() })
        .eq('id', loadBalancerId);

      // Generate stream URLs for this LB - use normalized stream name (lowercase, alphanumeric)
      const streamMappings = (streams || []).map(stream => {
        const normalizedName = stream.name.toLowerCase().replace(/[^a-z0-9]/g, "");
        return {
          name: stream.name,
          normalizedName: normalizedName,
          originalUrl: stream.input_url,
          proxyUrl: `http://${lb.ip_address}:${lb.nginx_port || 80}/live/${normalizedName}.ts?username=USER&password=PASS`
        };
      });

      return new Response(
        JSON.stringify({ 
          success: deploySuccess,
          message: deployMessage,
          config: nginxConfig,
          streams: streamMappings,
          loadBalancer: {
            name: lb.name,
            ip: lb.ip_address,
            port: lb.nginx_port || 80
          }
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (action === 'get-config') {
      return new Response(
        JSON.stringify({ 
          success: true,
          config: nginxConfig,
          streams: streams?.length || 0
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    return new Response(
      JSON.stringify({ error: 'Invalid action' }),
      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('LB Deploy error:', errorMessage);
    return new Response(
      JSON.stringify({ error: errorMessage }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
