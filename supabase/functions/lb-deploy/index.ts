import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface Stream {
  id: string;
  name: string;
  input_url: string;
  input_type: string;
  proxy_mode: string;
}

interface LoadBalancer {
  id: string;
  name: string;
  ip_address: string;
  port: number;
  nginx_port: number;
  ssh_username: string;
  ssh_password: string;
}

// Generate Nginx configuration with auth_request and reverse proxy (hides source URL)
function generateNginxConfig(streams: Stream[], lbPort: number, supabaseUrl: string, supabaseKey: string): string {
  // Build map entries - lowercase keys for case-insensitive matching
  // Maps stream name -> full backend URL for proxying
  const hostMapEntries: string[] = [];
  const basePathMapEntries: string[] = [];
  
  streams.forEach((stream) => {
    const streamName = stream.name;
    const lowerName = streamName.toLowerCase();
    const normalizedName = lowerName.replace(/[^a-z0-9]/g, '');
    const inputUrl = stream.input_url;
    
    // Parse URL to get host and base path
    try {
      const url = new URL(inputUrl);
      const hostWithProtocol = `${url.protocol}//${url.host}`;
      // Get base path (directory containing manifest)
      const basePath = url.pathname.substring(0, url.pathname.lastIndexOf('/') + 1);
      
      // Map stream name to full host URL
      hostMapEntries.push(`    "${lowerName}" "${hostWithProtocol}";`);
      basePathMapEntries.push(`    "${lowerName}" "${basePath}";`);
      
      // Add normalized version if different
      if (normalizedName !== lowerName) {
        hostMapEntries.push(`    "${normalizedName}" "${hostWithProtocol}";`);
        basePathMapEntries.push(`    "${normalizedName}" "${basePath}";`);
      }
    } catch (e) {
      hostMapEntries.push(`    "${lowerName}" "${inputUrl}";`);
      basePathMapEntries.push(`    "${lowerName}" "/";`);
    }
  });

  // Stream names for debug endpoint
  const streamList = streams.map(s => `"${s.name}"`).join(',');
  const streamDebug = JSON.stringify(streams.map(s => {
    try {
      const url = new URL(s.input_url);
      return { 
        name: s.name, 
        lower: s.name.toLowerCase(),
        host: url.host,
        basePath: url.pathname.substring(0, url.pathname.lastIndexOf('/') + 1)
      };
    } catch {
      return { name: s.name, lower: s.name.toLowerCase(), host: '', basePath: '/' };
    }
  })).replace(/"/g, '\\"');

  return `# Auto-generated by StreamPanel Load Balancer
# Generated: ${new Date().toISOString()}
# Streams: ${streams.length}
# Mode: Auth + Full HLS Proxy (source URL hidden, manifests rewritten)

# Stream host mapping (lowercase keys) - full protocol://host
map $stream_name_lower $stream_backend_host {
    default "";
${hostMapEntries.join('\n')}
}

# Stream base path mapping (for segment proxying)
map $stream_name_lower $stream_base_path {
    default "";
${basePathMapEntries.join('\n')}
}

server {
    listen ${lbPort};
    server_name _;
    
    resolver 8.8.8.8 8.8.4.4 valid=300s;
    resolver_timeout 5s;

    # Health check
    location /health {
        default_type text/plain;
        return 200 'OK';
    }

    # Stream status
    location /status {
        default_type application/json;
        return 200 '{"streams": ${streams.length}, "generated": "${new Date().toISOString()}", "names": [${streamList}]}';
    }

    # Debug - list streams with paths
    location /debug/streams {
        default_type application/json;
        return 200 "${streamDebug}";
    }

    # Auth subrequest - validates against Supabase
    location = /_auth {
        internal;
        proxy_pass ${supabaseUrl}/rest/v1/streaming_users?select=id&username=eq.$arg_username&password=eq.$arg_password&status=eq.active;
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
        proxy_set_header apikey "${supabaseKey}";
        proxy_set_header Authorization "Bearer ${supabaseKey}";
        proxy_set_header Prefer "return=representation";
    }

    # Live streams entry point - authenticates and serves manifest
    # Format: /live/STREAMNAME.ts?username=X&password=Y
    location ~ ^/live/([^/]+)\\.ts$ {
        set $stream_name $1;
        set $stream_name_lower $1;
        
        # Check credentials first
        if ($arg_username = "") {
            return 401 '{"error":"Missing username"}';
        }
        if ($arg_password = "") {
            return 401 '{"error":"Missing password"}';
        }

        # Authenticate via Supabase
        auth_request /_auth;
        auth_request_set $auth_status $upstream_status;
        
        # Redirect to stream path with credentials in cookie
        # This creates a session-like behavior
        add_header Set-Cookie "sp_stream=$stream_name_lower; Path=/s/$stream_name_lower/; HttpOnly" always;
        add_header Set-Cookie "sp_auth=1; Path=/s/$stream_name_lower/; HttpOnly" always;
        
        # Redirect to the manifest under /s/streamname/
        return 302 /s/$stream_name_lower/manifest.m3u8;
    }

    # HLS segment and manifest proxy - handles all requests under /s/STREAMNAME/
    # This proxies manifests AND segments, rewriting URLs in manifests
    location ~ ^/s/([^/]+)/(.*)$ {
        set $stream_name_lower $1;
        set $segment_path $2;
        
        # Check for auth cookie
        if ($cookie_sp_auth != "1") {
            return 401 '{"error":"Unauthorized - use /live/STREAMNAME.ts?username=X&password=Y first"}';
        }
        
        # Check stream exists
        if ($stream_backend_host = "") {
            return 404 '{"error":"Stream not found","name":"$stream_name_lower"}';
        }
        
        # Proxy to backend: host + base_path + requested segment
        proxy_pass $stream_backend_host$stream_base_path$segment_path$is_args$args;
        proxy_http_version 1.1;
        
        # Essential headers
        proxy_set_header Host $proxy_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Connection "";
        
        # Rewrite manifest content - replace origin URLs with LB URLs
        # This is crucial for HLS to work - segments must point to LB
        sub_filter_types application/vnd.apple.mpegurl application/x-mpegURL text/plain;
        sub_filter_once off;
        
        # Rewrite absolute URLs in manifests to use LB
        sub_filter '$stream_backend_host$stream_base_path' '/s/$stream_name_lower/';
        sub_filter '$stream_backend_host/' '/s/$stream_name_lower/';
        
        # Streaming optimizations
        proxy_buffering off;
        proxy_cache off;
        proxy_request_buffering off;
        chunked_transfer_encoding on;
        
        # Timeouts
        proxy_connect_timeout 10s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
        
        # Buffer settings
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;
        
        # Rewrite any absolute redirects from origin to LB /s/<stream>/ path
        proxy_redirect ~^https?://[^/]+(/.*)$ $scheme://$host:$server_port/s/$stream_name_lower$1;
        
        # CORS
        add_header Access-Control-Allow-Origin * always;
        add_header Access-Control-Allow-Methods 'GET, OPTIONS' always;
        add_header Access-Control-Expose-Headers 'Content-Length,Content-Range' always;
    }

    # Fallback
    location / {
        default_type application/json;
        return 404 '{"error":"Not found","hint":"Use /live/STREAMNAME.ts?username=X&password=Y"}';
    }
}`;
}

// Helper to escape regex special characters
function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { action, loadBalancerId } = await req.json();
    
    console.log(`LB Deploy action: ${action}, LB ID: ${loadBalancerId}`);

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Get load balancer details
    const { data: lb, error: lbError } = await supabase
      .from('load_balancers')
      .select('*')
      .eq('id', loadBalancerId)
      .single();

    if (lbError || !lb) {
      console.error('Load balancer not found:', lbError);
      return new Response(
        JSON.stringify({ error: 'Load balancer not found' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (!lb.ssh_username || !lb.ssh_password) {
      console.error('SSH credentials not configured for LB');
      return new Response(
        JSON.stringify({ error: 'SSH credentials not configured for this Load Balancer' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Get streams assigned to this load balancer
    const { data: streams, error: streamsError } = await supabase
      .from('streams')
      .select('id, name, input_url, input_type, proxy_mode')
      .eq('load_balancer_id', loadBalancerId);

    if (streamsError) {
      console.error('Error fetching streams:', streamsError);
      return new Response(
        JSON.stringify({ error: 'Failed to fetch streams' }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Get anon key for auth requests
    const anonKey = Deno.env.get('SUPABASE_ANON_KEY') || supabaseKey;
    const nginxConfig = generateNginxConfig(streams || [], lb.nginx_port || 80, supabaseUrl, anonKey);
    console.log(`Generated config for ${streams?.length || 0} streams`);

    // Agent always runs on port 3002
    const AGENT_PORT = '3002';
    const AGENT_SECRET = 'superbase123';

    if (action === 'test') {
      // Test agent connection
      const agentUrl = `http://${lb.ip_address}:${AGENT_PORT}/health`;
      console.log(`Testing agent at ${agentUrl}`);
      try {
        const testResponse = await fetch(agentUrl, {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
          signal: AbortSignal.timeout(5000),
        });
        
        if (testResponse.ok) {
          return new Response(
            JSON.stringify({ 
              success: true, 
              message: 'Agent connection successful',
              streams: streams?.length || 0
            }),
            { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
          );
        }
      } catch (e) {
        console.log('Agent not available, will try direct SSH');
      }

      return new Response(
        JSON.stringify({ 
          success: true, 
          message: 'Ready for deployment',
          config: nginxConfig,
          streams: streams?.length || 0
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (action === 'deploy') {
      // Try to deploy via agent - agent runs on port 3002
      const agentUrl = `http://${lb.ip_address}:${AGENT_PORT}`;
      
      let deploySuccess = false;
      let deployMessage = '';

      console.log(`Attempting deploy to agent at ${agentUrl}`);

      try {
        // Step 1: Write config file
        const writeResponse = await fetch(agentUrl, {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'X-Agent-Secret': AGENT_SECRET
          },
          body: JSON.stringify({
            action: 'execute',
            command: `cat > /etc/nginx/sites-available/streampanel-lb.conf << 'NGINXEOF'
${nginxConfig}
NGINXEOF`
          }),
          signal: AbortSignal.timeout(30000),
        });

        console.log(`Write config response: ${writeResponse.status}`);
        const writeResult = await writeResponse.json();
        console.log('Write result:', JSON.stringify(writeResult));

        if (writeResponse.ok && writeResult.success) {
          // Step 2: Enable site and reload nginx
          const reloadResponse = await fetch(agentUrl, {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'X-Agent-Secret': AGENT_SECRET
            },
            body: JSON.stringify({
              action: 'execute',
              command: 'ln -sf /etc/nginx/sites-available/streampanel-lb.conf /etc/nginx/sites-enabled/ && nginx -t && systemctl reload nginx'
            }),
            signal: AbortSignal.timeout(30000),
          });

          console.log(`Reload nginx response: ${reloadResponse.status}`);
          const reloadResult = await reloadResponse.json();
          console.log('Reload result:', JSON.stringify(reloadResult));

          if (reloadResponse.ok && reloadResult.success) {
            deploySuccess = true;
            deployMessage = 'Configuration deployed and nginx reloaded successfully';
          } else {
            deployMessage = `Nginx reload failed: ${reloadResult.output || 'Unknown error'}`;
          }
        } else {
          deployMessage = `Config write failed: ${writeResult.output || 'Unknown error'}`;
        }
      } catch (e) {
        const errorMsg = e instanceof Error ? e.message : 'Unknown error';
        console.log('Agent deployment failed:', errorMsg);
        deployMessage = `Agent error: ${errorMsg}`;
      }

      // Update last_deploy timestamp
      await supabase
        .from('load_balancers')
        .update({ last_deploy: new Date().toISOString() })
        .eq('id', loadBalancerId);

      // Generate stream URLs for this LB - use exact stream name format
      const streamMappings = (streams || []).map(stream => ({
        name: stream.name,
        originalUrl: stream.input_url,
        proxyUrl: `http://${lb.ip_address}:${lb.nginx_port || 80}/live/${encodeURIComponent(stream.name)}.ts?username=USER&password=PASS`
      }));

      return new Response(
        JSON.stringify({ 
          success: deploySuccess,
          message: deployMessage,
          config: nginxConfig,
          streams: streamMappings,
          loadBalancer: {
            name: lb.name,
            ip: lb.ip_address,
            port: lb.nginx_port || 80
          }
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (action === 'get-config') {
      return new Response(
        JSON.stringify({ 
          success: true,
          config: nginxConfig,
          streams: streams?.length || 0
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    return new Response(
      JSON.stringify({ error: 'Invalid action' }),
      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('LB Deploy error:', errorMessage);
    return new Response(
      JSON.stringify({ error: errorMessage }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
